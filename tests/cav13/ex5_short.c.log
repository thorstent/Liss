Running actions
Building sequential automaton
25 rounds; seen states: 29; transitions: 52
Checking if the trace is actually a counter example
5 rounds; seen states: 5; transitions: 4
Not Included
0-yi[ex5_short.c:38]
0-wn(open)[ex5_short.c:11]
0-w(power_on)[ex5_short.c:12]
0-no(open)[ex5_short.c:16]
1-wa(open)[ex5_short.c:46]
1-rs(open)[ex5_short.c:25]
1-wn(open)[ex5_short.c:28]
1-w(power_on)[ex5_short.c:29]
0-r(power_on)[ex5_short.c:18]
1-r(power_on)[ex5_short.c:32]
1-yi[ex5_short.c:48]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 1-w(power_on)[ex5_short.c:29] < 0-r(power_on)[ex5_short.c:18] /\ 0-no(open)[ex5_short.c:16] < 1-rs(open)[ex5_short.c:25]
Found constraints to eliminate bad traces
Locks inferred: 
l1 (1-rs(open)[ex5_short.c:25]-1-w(power_on)[ex5_short.c:29], 0-no(open)[ex5_short.c:16]-0-r(power_on)[ex5_short.c:18])
1-rs(open)[ex5_short.c:25]
1-wn(open)[ex5_short.c:28]
1-w(power_on)[ex5_short.c:29]
-------------------
0-no(open)[ex5_short.c:16]
0-r(power_on)[ex5_short.c:18]
-------------------


TIME - Iteration 1: 0.032s

39 rounds; seen states: 42; transitions: 83
Checking if the trace is actually a counter example
7 rounds; seen states: 7; transitions: 6
Not Included
0-yi[ex5_short.c:38]
0-wn(open)[ex5_short.c:11]
0-w(power_on)[ex5_short.c:12]
0-no(open)[ex5_short.c:16]
0-r(power_on)[ex5_short.c:18]
1-wa(open)[ex5_short.c:46]
1-rs(open)[ex5_short.c:25]
1-wn(open)[ex5_short.c:28]
1-w(power_on)[ex5_short.c:29]
0-yi[ex5_short.c:38]
0-wn(open)[ex5_short.c:11]
0-w(power_on)[ex5_short.c:12]
0-no(open)[ex5_short.c:16]
0-r(power_on)[ex5_short.c:18]
1-r(power_on)[ex5_short.c:32]
1-yi[ex5_short.c:48]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 1-w(power_on)[ex5_short.c:29] < 0-w(power_on)[ex5_short.c:12](2) /\ 0-w(power_on)[ex5_short.c:12](2) < 1-r(power_on)[ex5_short.c:32] \/
0-w(power_on)[ex5_short.c:12](2) < 1-w(power_on)[ex5_short.c:29] /\ 1-rs(open)[ex5_short.c:25] < 0-wn(open)[ex5_short.c:11](2)
Found constraints to eliminate bad traces
Locks inferred: 
l2 (1-w(power_on)[ex5_short.c:29]-1-r(power_on)[ex5_short.c:32], 0-w(power_on)[ex5_short.c:12](2)-0-w(power_on)[ex5_short.c:12](2)) /\ 
l3 (1-rs(open)[ex5_short.c:25]-1-w(power_on)[ex5_short.c:29], 0-wn(open)[ex5_short.c:11](2)-0-w(power_on)[ex5_short.c:12](2))
1-w(power_on)[ex5_short.c:29]
1-r(power_on)[ex5_short.c:32]
-------------------
0-w(power_on)[ex5_short.c:12]
-------------------
 /\ 
1-rs(open)[ex5_short.c:25]
1-wn(open)[ex5_short.c:28]
1-w(power_on)[ex5_short.c:29]
-------------------
0-wn(open)[ex5_short.c:11]
0-w(power_on)[ex5_short.c:12]
-------------------


TIME - Iteration 2: 0.038s

59 rounds; seen states: 54; transitions: 134
Checking if the trace is actually a counter example
6 rounds; seen states: 6; transitions: 5
Not Included
0-yi[ex5_short.c:38]
0-wn(open)[ex5_short.c:11]
0-w(power_on)[ex5_short.c:12]
0-no(open)[ex5_short.c:16]
0-r(power_on)[ex5_short.c:18]
1-wa(open)[ex5_short.c:46]
1-rs(open)[ex5_short.c:25]
0-yi[ex5_short.c:38]
0-wn(open)[ex5_short.c:11]
0-w(power_on)[ex5_short.c:12]
0-no(open)[ex5_short.c:16]
0-r(power_on)[ex5_short.c:18]
1-r(power_on)[ex5_short.c:32]
1-yi[ex5_short.c:48]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 0-w(power_on)[ex5_short.c:12](2) < 1-r(power_on)[ex5_short.c:32] /\ 1-rs(open)[ex5_short.c:25] < 0-wn(open)[ex5_short.c:11](2)
Found constraints to eliminate bad traces
Locks inferred: 
l4 (1-rs(open)[ex5_short.c:25]-1-r(power_on)[ex5_short.c:32], 0-wn(open)[ex5_short.c:11](2)-0-w(power_on)[ex5_short.c:12](2))
1-rs(open)[ex5_short.c:25]
1-r(power_on)[ex5_short.c:32]
-------------------
0-wn(open)[ex5_short.c:11]
0-w(power_on)[ex5_short.c:12]
-------------------


TIME - Iteration 3: 0.03s

78 rounds; seen states: 69; transitions: 177
Checking if the trace is actually a counter example
6 rounds; seen states: 6; transitions: 5
Not Included
0-yi[ex5_short.c:38]
0-wn(open)[ex5_short.c:11]
0-w(power_on)[ex5_short.c:12]
0-no(open)[ex5_short.c:16]
0-r(power_on)[ex5_short.c:18]
1-wa(open)[ex5_short.c:46]
0-yi[ex5_short.c:38]
0-wa(open)[ex5_short.c:14]
1-rs(open)[ex5_short.c:25]
1-wn(open)[ex5_short.c:28]
1-w(power_on)[ex5_short.c:29]
0-no(open)[ex5_short.c:16]
0-r(power_on)[ex5_short.c:18]
1-r(power_on)[ex5_short.c:32]
1-yi[ex5_short.c:48]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 0-wa(open)[ex5_short.c:14](2) < 1-rs(open)[ex5_short.c:25] /\ 1-rs(open)[ex5_short.c:25] < 0-no(open)[ex5_short.c:16](2)
Found constraints to eliminate bad traces
Locks inferred: 
l5 (1-rs(open)[ex5_short.c:25]-1-rs(open)[ex5_short.c:25], 0-wa(open)[ex5_short.c:14](2)-0-no(open)[ex5_short.c:16](2))
1-rs(open)[ex5_short.c:25]
-------------------
0-wa(open)[ex5_short.c:14]
0-no(open)[ex5_short.c:16]
-------------------


TIME - Iteration 4: 0.034s

81 rounds; seen states: 64; transitions: 193
Included
Synthesis was successful.
Threads: 2
Iterations: 4
Liss: 0s
Verification: 0s
Synthesis: 0.132s
Memory: 33MB
Total number of conflicts found: 5
2 | 4 | 1 | 0s | 0.132s | 0s | 0.132s | 33MB
Lock statistics:
---------------
Starting lock placement for absmin
Cost function 2: Absolute minimum of instructions inside a lock:
Number of locks used: 1
Number of lock operations: 3
Number of unlock operations: 2
Number of abstract instructions inside a lock: 9
Time for this cost function: 0.032s

Starting lock placement for small
Cost function 3: Smallest locks:
Number of locks used: 2
Number of lock operations: 5
Number of unlock operations: 4
Number of abstract instructions inside a lock: 9
Time for this cost function: 0.046s

Starting lock placement for coarse
Cost function 4: Coarse locks:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 9
Time for this cost function: 0.059s

