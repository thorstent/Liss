Running actions
Building sequential automaton
43 rounds; seen states: 47; transitions: 92
Checking if the trace is actually a counter example
5 rounds; seen states: 5; transitions: 4
Not Included
0-yi[ex5.c:76]
0-wn(open)[ex5.c:39]
0-w(power_on)[ex5.c:40]
0-no(open)[ex5.c:44]
1-wa(open)[ex5.c:84]
1-lo(l)[ex5.c:58]
1-rs(open)[ex5.c:60]
1-wn(open)[ex5.c:63]
1-w(power_on)[ex5.c:64]
0-r(power_on)[ex5.c:46]
1-r(power_on)[ex5.c:67]
1-un(l)[ex5.c:70]
1-yi[ex5.c:86]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 1-w(power_on)[ex5.c:64] < 0-r(power_on)[ex5.c:46] /\ 0-no(open)[ex5.c:44] < 1-rs(open)[ex5.c:60]
Found constraints to eliminate bad traces
Locks inferred: 
l1 (1-rs(open)[ex5.c:60]-1-w(power_on)[ex5.c:64], 0-no(open)[ex5.c:44]-0-r(power_on)[ex5.c:46])
1-rs(open)[ex5.c:60]
1-wn(open)[ex5.c:63]
1-w(power_on)[ex5.c:64]
-------------------
0-no(open)[ex5.c:44]
0-r(power_on)[ex5.c:46]
-------------------


TIME - Iteration 1: 0.032s

53 rounds; seen states: 55; transitions: 114
Checking if the trace is actually a counter example
7 rounds; seen states: 7; transitions: 6
Not Included
0-yi[ex5.c:76]
0-wn(open)[ex5.c:39]
0-w(power_on)[ex5.c:40]
0-no(open)[ex5.c:44]
0-r(power_on)[ex5.c:46]
1-wa(open)[ex5.c:84]
1-lo(l)[ex5.c:58]
1-rs(open)[ex5.c:60]
1-wn(open)[ex5.c:63]
1-w(power_on)[ex5.c:64]
0-yi[ex5.c:76]
0-wn(open)[ex5.c:39]
0-w(power_on)[ex5.c:40]
0-no(open)[ex5.c:44]
0-r(power_on)[ex5.c:46]
1-r(power_on)[ex5.c:67]
1-un(l)[ex5.c:70]
1-yi[ex5.c:86]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 1-w(power_on)[ex5.c:64] < 0-w(power_on)[ex5.c:40](2) /\ 0-w(power_on)[ex5.c:40](2) < 1-r(power_on)[ex5.c:67] \/
0-w(power_on)[ex5.c:40](2) < 1-w(power_on)[ex5.c:64] /\ 1-rs(open)[ex5.c:60] < 0-wn(open)[ex5.c:39](2)
Found constraints to eliminate bad traces
Locks inferred: 
l2 (1-w(power_on)[ex5.c:64]-1-r(power_on)[ex5.c:67], 0-w(power_on)[ex5.c:40](2)-0-w(power_on)[ex5.c:40](2)) /\ 
l3 (1-rs(open)[ex5.c:60]-1-w(power_on)[ex5.c:64], 0-wn(open)[ex5.c:39](2)-0-w(power_on)[ex5.c:40](2))
1-w(power_on)[ex5.c:64]
1-r(power_on)[ex5.c:67]
-------------------
0-w(power_on)[ex5.c:40]
-------------------
 /\ 
1-rs(open)[ex5.c:60]
1-wn(open)[ex5.c:63]
1-w(power_on)[ex5.c:64]
-------------------
0-wn(open)[ex5.c:39]
0-w(power_on)[ex5.c:40]
-------------------


TIME - Iteration 2: 0.04s

75 rounds; seen states: 67; transitions: 169
Checking if the trace is actually a counter example
6 rounds; seen states: 6; transitions: 5
Not Included
0-yi[ex5.c:76]
0-wn(open)[ex5.c:39]
0-w(power_on)[ex5.c:40]
0-no(open)[ex5.c:44]
0-r(power_on)[ex5.c:46]
1-wa(open)[ex5.c:84]
1-lo(l)[ex5.c:58]
1-rs(open)[ex5.c:60]
0-yi[ex5.c:76]
0-wn(open)[ex5.c:39]
0-w(power_on)[ex5.c:40]
0-no(open)[ex5.c:44]
0-r(power_on)[ex5.c:46]
1-r(power_on)[ex5.c:67]
1-un(l)[ex5.c:70]
1-yi[ex5.c:86]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 0-w(power_on)[ex5.c:40](2) < 1-r(power_on)[ex5.c:67] /\ 1-rs(open)[ex5.c:60] < 0-wn(open)[ex5.c:39](2)
Found constraints to eliminate bad traces
Locks inferred: 
l4 (1-rs(open)[ex5.c:60]-1-r(power_on)[ex5.c:67], 0-wn(open)[ex5.c:39](2)-0-w(power_on)[ex5.c:40](2))
1-rs(open)[ex5.c:60]
1-r(power_on)[ex5.c:67]
-------------------
0-wn(open)[ex5.c:39]
0-w(power_on)[ex5.c:40]
-------------------


TIME - Iteration 3: 0.032s

97 rounds; seen states: 83; transitions: 218
Checking if the trace is actually a counter example
6 rounds; seen states: 6; transitions: 5
Not Included
0-yi[ex5.c:76]
0-wn(open)[ex5.c:39]
0-w(power_on)[ex5.c:40]
0-no(open)[ex5.c:44]
0-r(power_on)[ex5.c:46]
1-wa(open)[ex5.c:84]
1-lo(l)[ex5.c:58]
0-yi[ex5.c:76]
0-wa(open)[ex5.c:42]
1-rs(open)[ex5.c:60]
1-wn(open)[ex5.c:63]
1-w(power_on)[ex5.c:64]
0-no(open)[ex5.c:44]
0-r(power_on)[ex5.c:46]
1-r(power_on)[ex5.c:67]
1-un(l)[ex5.c:70]
1-yi[ex5.c:86]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 0-wa(open)[ex5.c:42](2) < 1-rs(open)[ex5.c:60] /\ 1-rs(open)[ex5.c:60] < 0-no(open)[ex5.c:44](2)
Found constraints to eliminate bad traces
Locks inferred: 
l5 (1-rs(open)[ex5.c:60]-1-rs(open)[ex5.c:60], 0-wa(open)[ex5.c:42](2)-0-no(open)[ex5.c:44](2))
1-rs(open)[ex5.c:60]
-------------------
0-wa(open)[ex5.c:42]
0-no(open)[ex5.c:44]
-------------------


TIME - Iteration 4: 0.037s

100 rounds; seen states: 79; transitions: 235
Included
Synthesis was successful.
Threads: 2
Iterations: 4
Liss: 0s
Verification: 0s
Synthesis: 0.14s
Memory: 33MB
Total number of conflicts found: 5
2 | 4 | 1 | 0s | 0.14s | 0s | 0.14s | 33MB
Lock statistics:
---------------
Starting lock placement for absmin
Cost function 2: Absolute minimum of instructions inside a lock:
Number of locks used: 1
Number of lock operations: 3
Number of unlock operations: 2
Number of abstract instructions inside a lock: 9
Time for this cost function: 0.038s

Starting lock placement for small
Cost function 3: Smallest locks:
Number of locks used: 2
Number of lock operations: 5
Number of unlock operations: 4
Number of abstract instructions inside a lock: 9
Time for this cost function: 0.05s

Starting lock placement for coarse
Cost function 4: Coarse locks:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 9
Time for this cost function: 0.058s

