Running actions
Building sequential automaton
16 rounds; seen states: 18; transitions: 25
Found candidate ... Checking if truely a counter-example(size=9)
6 rounds; seen states: 6; transitions: 5
Candidate is not a counter-example
Increasing the bound to 2
12 rounds; seen states: 20; transitions: 17
Checking if the trace is actually a counter example
7 rounds; seen states: 7; transitions: 6
Not Included
1-lo(l)[ipath.c:46]
1-r(ipath_pd)[ipath.c:49]
1-un(l)[ipath.c:51]
0-lo(l)[ipath.c:29]
0-r(ipath_pd)[ipath.c:32]
1-w(ipath_pd)[ipath.c:62]
0-r(ipath_pd)[ipath.c:35]
0-un(l)[ipath.c:39]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 0-r(ipath_pd)[ipath.c:32] < 1-w(ipath_pd)[ipath.c:62] /\ 1-w(ipath_pd)[ipath.c:62] < 0-r(ipath_pd)[ipath.c:35]
Found constraints to eliminate bad traces
Locks inferred: 
l1 (1-w(ipath_pd)[ipath.c:62]-1-w(ipath_pd)[ipath.c:62], 0-r(ipath_pd)[ipath.c:32]-0-r(ipath_pd)[ipath.c:35])
1-w(ipath_pd)[ipath.c:62]
-------------------
0-r(ipath_pd)[ipath.c:32]
0-r(ipath_pd)[ipath.c:35]
-------------------


TIME - Iteration 1: 0.015s

17 rounds; seen states: 22; transitions: 26
Found candidate ... Checking if truely a counter-example(size=9)
6 rounds; seen states: 6; transitions: 5
Candidate is not a counter-example
Increasing the bound to 2
24 rounds; seen states: 29; transitions: 39
Found candidate ... Checking if truely a counter-example(size=12)
9 rounds; seen states: 9; transitions: 8
Candidate is not a counter-example
Increasing the bound to 3
42 rounds; seen states: 49; transitions: 79
Included
Synthesis was successful.
Threads: 2
Iterations: 1
Liss: 0s
Verification: 0s
Synthesis: 0.015s
Memory: 30MB
Total number of conflicts found: 1
2 | 1 | 3 | 0s | 0.015s | 0s | 0.015s | 30MB
Lock statistics:
---------------
Starting lock placement for absmin
Lock placement succeeded!
Cost function 2: Absolute minimum of instructions inside a lock:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 3
Time for this cost function: 0.001s

Starting lock placement for coarse
Lock placement succeeded!
Cost function 3: Coarse locks:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 7
Time for this cost function: 0.005s

Starting lock placement for unopt
Lock placement succeeded!
Cost function 4: No cost function:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 3
Time for this cost function: 0.001s

Starting lock placement for small
Lock placement succeeded!
Cost function 5: Smallest locks:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 3
Time for this cost function: 0.001s

Starting lock placement for maxconc
Lock placement succeeded!
Cost function 6: Maximum concurrency:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 3
Time for this cost function: 0.001s

