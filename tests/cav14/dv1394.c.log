Running actions
Building sequential automaton
29 rounds; seen states: 28; transitions: 39
Checking if the trace is actually a counter example
10 rounds; seen states: 10; transitions: 9
Not Included
1-lo(mtx)[dv1394.c:77]
1-r(state)[dv1394.c:82]
1-w(state)[dv1394.c:84]
1-un(mtx)[dv1394.c:87]
1-lo(sem)[dv1394.c:94]
1-un(sem)[dv1394.c:100]
0-lo(sem)[dv1394.c:34]
0-w(vm_consistent)[dv1394.c:39]
0-lo(mtx)[dv1394.c:50]
0-w(state)[dv1394.c:55]
1-w(state)[dv1394.c:104]
0-w(state)[dv1394.c:57]
0-w(state)[dv1394.c:59]
0-w(state)[dv1394.c:61]
0-un(mtx)[dv1394.c:64]
0-w(vm_consistent)[dv1394.c:68]
0-un(sem)[dv1394.c:70]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 0-w(state)[dv1394.c:55] < 1-w(state)[dv1394.c:104] /\ 1-w(state)[dv1394.c:104] < 0-w(state)[dv1394.c:57] \/
0-w(state)[dv1394.c:57] < 1-w(state)[dv1394.c:104] /\ 1-w(state)[dv1394.c:104] < 0-w(state)[dv1394.c:61]
Found constraints to eliminate bad traces
Locks inferred: 
l1 (1-w(state)[dv1394.c:104]-1-w(state)[dv1394.c:104], 0-w(state)[dv1394.c:55]-0-w(state)[dv1394.c:57]) /\ 
l2 (1-w(state)[dv1394.c:104]-1-w(state)[dv1394.c:104], 0-w(state)[dv1394.c:57]-0-w(state)[dv1394.c:61])
1-w(state)[dv1394.c:104]
-------------------
0-w(state)[dv1394.c:55]
0-w(state)[dv1394.c:57]
-------------------
 /\ 
1-w(state)[dv1394.c:104]
-------------------
0-w(state)[dv1394.c:57]
0-w(state)[dv1394.c:59]
0-w(state)[dv1394.c:61]
-------------------


TIME - Iteration 1: 0.03s

70 rounds; seen states: 67; transitions: 128
Included
Synthesis was successful.
Threads: 2
Iterations: 1
Liss: 0s
Verification: 0s
Synthesis: 0.029s
Memory: 32MB
Total number of conflicts found: 2
2 | 1 | 1 | 0s | 0.029s | 0s | 0.029s | 32MB
Lock statistics:
---------------
Starting lock placement for absmin
Lock placement succeeded!
Cost function 2: Absolute minimum of instructions inside a lock:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 5
Time for this cost function: 0.006s

Starting lock placement for coarse
Lock placement succeeded!
Cost function 3: Coarse locks:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 5
Time for this cost function: 0.011s

Starting lock placement for unopt
Lock placement succeeded!
Cost function 4: No cost function:
Number of locks used: 1
Number of lock operations: 3
Number of unlock operations: 3
Number of abstract instructions inside a lock: 7
Time for this cost function: 0.003s

Starting lock placement for small
Lock placement succeeded!
Cost function 5: Smallest locks:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 5
Time for this cost function: 0.006s

Starting lock placement for maxconc
Lock placement succeeded!
Cost function 6: Maximum concurrency:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 5
Time for this cost function: 0.006s

