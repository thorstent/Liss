Running actions
Building sequential automaton
23 rounds; seen states: 23; transitions: 40
Checking if the trace is actually a counter example
4 rounds; seen states: 4; transitions: 3
Not Included
0-no(work)[md.c:36]
0-no(removed)[md.c:75]
1-wa(removed)[md.c:80]
1-lo(l)[md.c:45]
1-r(sysfs_entry)[md.c:50]
2-wa(work)[md.c:90]
2-w(sysfs_entry)[md.c:92]
1-w(sysfs_entry)[md.c:53]
1-un(l)[md.c:56]
2-rs(work)[md.c:104]
Find all sequential traces
Find concurrent traces that are not sequential
All bad traces: 
(*) 1-r(sysfs_entry)[md.c:50] < 2-w(sysfs_entry)[md.c:92] /\ 2-w(sysfs_entry)[md.c:92] < 1-w(sysfs_entry)[md.c:53]
Found constraints to eliminate bad traces
Locks inferred: 
l1 (2-w(sysfs_entry)[md.c:92]-2-w(sysfs_entry)[md.c:92], 1-r(sysfs_entry)[md.c:50]-1-w(sysfs_entry)[md.c:53])
2-w(sysfs_entry)[md.c:92]
-------------------
1-r(sysfs_entry)[md.c:50]
1-w(sysfs_entry)[md.c:53]
-------------------


TIME - Iteration 1: 0.027s

42 rounds; seen states: 42; transitions: 85
Included
Synthesis was successful.
Threads: 3
Iterations: 1
Liss: 0s
Verification: 0s
Synthesis: 0.027s
Memory: 30MB
Total number of conflicts found: 1
3 | 1 | 1 | 0s | 0.027s | 0s | 0.027s | 30MB
Lock statistics:
---------------
Starting lock placement for absmin
Cost function 2: Absolute minimum of instructions inside a lock:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 3
Time for this cost function: 0.004s

Starting lock placement for small
Cost function 3: Smallest locks:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 3
Time for this cost function: 0.003s

Starting lock placement for coarse
Cost function 4: Coarse locks:
Number of locks used: 1
Number of lock operations: 2
Number of unlock operations: 2
Number of abstract instructions inside a lock: 3
Time for this cost function: 0.005s

